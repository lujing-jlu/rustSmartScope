# YOLOv8 RKNN 详细性能分析报告

## 测试配置

- **模型**: YOLOv8m (models/yolov8m.rknn)
- **输入图片**: tests/test.jpg (640x406)
- **模型输入尺寸**: 640x640
- **硬件**: RK3588 NPU
- **量化**: INT8
- **测试迭代次数**: 100

## 详细时间分解（来自 C++ 代码计时）

###  单次推理各步骤耗时

```
[TIMING] Preprocess (RGA):  2.05ms  (  2.4%)
[TIMING] Input setup:       3.07ms  (  3.6%)
[TIMING] rknn_run (NPU):   78.20ms  ( 91.6%)  ← 主要瓶颈
[TIMING] Output get:        0.86ms  (  1.0%)
[TIMING] Postprocess (NMS): 1.16ms  (  1.4%)
────────────────────────────────────────────
[TIMING] Total:            85.34ms  (100.0%)
```

## 性能分析

### 1. 主要耗时组件

| 组件 | 耗时 | 占比 | 说明 |
|------|------|------|------|
| **NPU 推理 (rknn_run)** | **78.20ms** | **91.6%** | NPU 硬件执行，主要瓶颈 |
| Input setup | 3.07ms | 3.6% | 设置输入张量 |
| RGA 预处理 | 2.05ms | 2.4% | Letterbox + 格式转换 |
| NMS 后处理 | 1.16ms | 1.4% | 非极大值抑制 |
| Output get | 0.86ms | 1.0% | 获取输出张量 |

### 2. 100次迭代统计

**Rust 测量的总时间（包含所有 C++ 步骤）：**
- 平均时间：87.38ms
- 最小时间：81.42ms
- 最大时间：93.89ms
- 标准差：3.71ms
- 总时间（100x）：8738.05ms

**与 C++ 内部计时的对比：**
- C++ 内部计时：85.34ms
- Rust 外部计时：87.38ms
- 差异：~2ms （Rust FFI 调用开销）

### 3. 预处理对比

| 预处理方式 | 耗时 | 说明 |
|-----------|------|------|
| **C++ RGA 加速** | **2.05ms** | 硬件加速的 letterbox + 格式转换 |
| Rust image crate | 5.41ms | 纯软件实现（letterbox + resize） |

**结论**：RGA 硬件加速比纯软件实现快 **2.6倍**

## 性能瓶颈识别

### 🔴 主要瓶颈：NPU 推理 (78.20ms, 91.6%)

**原因：**
1. YOLOv8m 是中等大小模型，计算量较大
2. INT8 量化已经应用，但仍需约 78ms
3. RK3588 NPU 的硬件性能限制

**优化建议：**
1. 使用更小的模型（YOLOv8n/s）可降至 30-40ms
2. 降低输入分辨率（如 416x416）
3. 使用模型剪枝/蒸馏技术

### 🟡 次要开销

**Input setup (3.07ms)**：
- 设置 RKNN 输入张量参数
- 难以优化，属于必要开销

**RGA 预处理 (2.05ms)**：
- 已使用硬件加速
- 可接受的开销

**NMS 后处理 (1.16ms)**：
- CPU 执行的非极大值抑制
- 仅占 1.4%，无需优化

## 吞吐量分析

### 单图处理时间

| 场景 | 时间 | FPS |
|------|------|-----|
| **仅推理+后处理** | 87.38ms | 11.44 |
| **含 Rust 预处理** | 92.79ms | 10.78 |
| **含 RGA 预处理** | 85.34ms | 11.72 |

### 实际应用场景

1. **实时视频流（10 FPS）**
   - ✅ 可行
   - 平均 87ms，留有余地

2. **高帧率应用（30 FPS）**
   - ❌ 需要模型优化
   - 目标：<33ms per frame

3. **批处理**
   - ✅ 非常适合
   - 可并行处理多路视频流

## 与参考实现对比

| 实现 | 推理时间 | 说明 |
|------|---------|------|
| C++ 参考实现 | ~85ms | 原始实现 |
| **Rust 包装** | **87.38ms** | 几乎无性能损失（+2.4%） |

**结论**：Rust FFI 包装带来的开销可忽略不计（约 2ms）

## 优化建议

### 短期优化（无需修改模型）

1. **批处理推理**
   - 一次处理多张图片
   - 可提高吞吐量 20-30%

2. **异步处理**
   - 预处理、推理、后处理流水线化
   - 理论可提升 10-15%

### 中期优化（模型调整）

1. **使用 YOLOv8s**
   - 预期推理时间：~50-60ms
   - 精度损失：~2-3% mAP

2. **降低输入分辨率**
   - 640x640 → 416x416
   - 预期提升：30-40%
   - 小目标检测能力下降

### 长期优化（深度优化）

1. **模型剪枝**
   - 减少 30-50% 计算量
   - 需要重新训练和量化

2. **知识蒸馏**
   - 用小模型学习大模型
   - 在速度和精度间取得平衡

3. **算子融合**
   - 优化 RKNN 模型图
   - 需要深入了解 RKNN 工具链

## 硬件性能分析

### NPU 利用率

- **理论峰值**：RK3588 NPU ~6 TOPS (INT8)
- **实际利用**：取决于模型结构和访存模式
- **推理时间**：78.20ms 用于 YOLOv8m

### 内存带宽

- **模型大小**：~25MB (YOLOv8m INT8)
- **输入大小**：1.17MB (640x640x3)
- **输出大小**：~1.22MB (9个输出张量)

### RGA 加速效果

- **软件实现**：5.41ms
- **RGA 加速**：2.05ms
- **加速比**：2.6x

## 结论

### 性能总结

1. **总体性能**：87.38ms/图，11.44 FPS
2. **主要瓶颈**：NPU 推理占 91.6%
3. **Rust 开销**：可忽略（<3%）
4. **适用场景**：10 FPS 实时检测

### 关键发现

1. ✅ **NPU 推理是唯一瓶颈**
   - 78.20ms 占总时间 91.6%
   - 其他步骤总计 <7ms

2. ✅ **RGA 硬件加速效果显著**
   - 比纯软件快 2.6 倍
   - 仅需 2.05ms

3. ✅ **后处理非常高效**
   - NMS 仅需 1.16ms
   - CPU 实现已足够快

4. ✅ **Rust 封装零成本**
   - FFI 开销 <3%
   - 类型安全无性能损失

### 推荐配置

**实时检测（10-12 FPS）**：
- 当前配置已满足
- YOLOv8m + 640x640
- 87ms per frame

**高帧率（25-30 FPS）**：
- 使用 YOLOv8n
- 降低至 416x416
- 预期 <35ms per frame

**高精度**：
- 使用 YOLOv8l/x
- 接受 120-150ms
- 7-8 FPS

## 附录：详细计时日志

```
模型信息:
- Input: [1, 640, 640, 3] INT8, NHWC
- Outputs: 9 tensors (3 scales × 3 types)
- Quantization: AFFINE, zp=-128, scale=0.003922

第一次推理详细计时:
[TIMING] Preprocess (RGA):  2.05ms
[TIMING] Input setup:       3.07ms
[TIMING] rknn_run (NPU):    78.20ms
[TIMING] Output get:        0.86ms
[TIMING] Postprocess (NMS): 1.16ms
[TIMING] Total:             85.34ms

100次迭代统计:
- Average: 87.38ms
- Min:     81.42ms
- Max:     93.89ms
- Std:     3.71ms
```

---

**测试日期**: 2025-10-14
**硬件平台**: RK3588
**软件版本**: RKNN Runtime 1.10.1
**测试工具**: rustSmartScope/rknn-inference benchmark
