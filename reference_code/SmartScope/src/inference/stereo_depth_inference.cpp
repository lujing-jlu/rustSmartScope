#include "inference/stereo_depth_inference.hpp"
#include "stereo_depth/comprehensive_depth_processor.hpp"
#include <iostream>
#include <fstream>

namespace SmartScope {

StereoDepthInference::StereoDepthInference(const std::string& camera_param_dir, 
                                          const std::string& mono_model_path)
    : current_mode_(BALANCED) {
    
    try {
        // 创建处理器
        processor_ = std::make_unique<stereo_depth::ComprehensiveDepthProcessor>(
            camera_param_dir, mono_model_path);
            
        std::cout << "StereoDepthInference 初始化成功" << std::endl;
        
    } catch (const std::exception& e) {
        std::cerr << "StereoDepthInference 初始化失败: " << e.what() << std::endl;
        throw;
    }
}

StereoDepthInference::~StereoDepthInference() {
    // 智能指针会自动清理
}

cv::Mat StereoDepthInference::inference(const cv::Mat& left_img, const cv::Mat& right_img) {
    if (!processor_) {
        throw std::runtime_error("处理器未初始化");
    }
    
    try {
        // 使用 stereo_depth_lib 进行处理
        // 注意：SmartScope 已经对图像进行了立体校正，所以这里使用专门处理已校正图像的方法
        // 但是我们需要使用 SmartScope 的Q矩阵来确保深度计算正确
        // 获取 SmartScope 的Q矩阵
        cv::Mat Q_matrix = cv::Mat::eye(4, 4, CV_64F); // 默认单位矩阵
        // TODO: 从 SmartScope 的立体校正参数中获取Q矩阵
        // 注意：这里需要从 StereoCalibrationHelper 获取Q矩阵，但目前我们使用默认值
        auto result = processor_->processAlreadyRectifiedImages(left_img, right_img, Q_matrix);
        
        if (!result.success) {
            throw std::runtime_error("立体视觉处理失败");
        }
        
        // 返回融合后的深度图，如果没有则返回双目深度图
        if (!result.final_fused_depth.empty()) {
            return result.final_fused_depth;
        } else if (!result.stereo_depth_mm.empty()) {
            return result.stereo_depth_mm;
        } else {
            // 如果都没有，返回视差图作为备选
            return result.disparity;
        }
        
    } catch (const std::exception& e) {
        std::cerr << "推理失败: " << e.what() << std::endl;
        throw;
    }
}

void StereoDepthInference::setPerformanceMode(PerformanceMode mode) {
    current_mode_ = mode;
    updateOptionsForMode(mode);
}

StereoDepthInference::PerformanceMode StereoDepthInference::getPerformanceMode() const {
    return current_mode_;
}

void StereoDepthInference::updateOptionsForMode(PerformanceMode mode) {
    // 性能模式设置 - 暂时使用默认配置
    // 后续可以通过 processor_ 的接口来调整参数
    switch (mode) {
        case HIGH_QUALITY:
            // 高质量模式配置
            break;
            
        case BALANCED:
            // 平衡模式配置
            break;
            
        case FAST:
            // 快速模式配置
            break;
            
        case ULTRA_FAST:
            // 极速模式配置
            break;
    }
}

void StereoDepthInference::saveDisparity(const cv::Mat& disparity, const std::string& filename) {
    if (disparity.empty()) {
        std::cerr << "视差图为空，无法保存" << std::endl;
        return;
    }
    
    try {
        // 转换为8位图像用于保存
        cv::Mat disparity_8u;
        double min_val, max_val;
        cv::minMaxLoc(disparity, &min_val, &max_val);
        
        if (max_val > min_val) {
            disparity.convertTo(disparity_8u, CV_8U, 255.0 / (max_val - min_val), -min_val * 255.0 / (max_val - min_val));
        } else {
            disparity.convertTo(disparity_8u, CV_8U);
        }
        
        cv::imwrite(filename, disparity_8u);
        std::cout << "视差图已保存到: " << filename << std::endl;
        
    } catch (const std::exception& e) {
        std::cerr << "保存视差图失败: " << e.what() << std::endl;
    }
}

void StereoDepthInference::savePointCloud(const cv::Mat& disparity, const cv::Mat& color, 
                                         const std::string& filename,
                                         float baseline, float focal_length) {
    if (!processor_) {
        std::cerr << "处理器未初始化，无法保存点云" << std::endl;
        return;
    }
    
    try {
        // 使用 stereo_depth_lib 的点云保存功能
        bool success = processor_->saveRGBPointCloud(color, disparity, filename, "Generated by StereoDepthInference");
        
        if (success) {
            std::cout << "点云已保存到: " << filename << std::endl;
        } else {
            std::cerr << "保存点云失败" << std::endl;
        }
        
    } catch (const std::exception& e) {
        std::cerr << "保存点云失败: " << e.what() << std::endl;
    }
}

} // namespace SmartScope 